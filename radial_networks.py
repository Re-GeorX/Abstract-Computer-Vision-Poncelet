# -*- coding: utf-8 -*-
"""radial-networks.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1BGMvEkxcfTrrn5B640ISWHBn5ZsgK_O8
"""

class RadialDense1D(tf.keras.layers.Layer):
    def __init__(self,units):
        super(RadialDense1D, self).__init__()
        self.units=units

    def build(self,input_shape):
        print(input_shape)
        self.centers=self.add_weight(
            name='centers',
            shape=[self.units,1,int(input_shape[-1])],
            initializer="random_normal",
            trainable=True
        )
        self.weight=self.add_weight(
            name='weight',
            shape=2*[self.units],
            initializer="random_normal",
            trainable=True
        )
        self.lambd=self.add_weight(
             name='lambda',
            shape=[1],
            initializer="random_normal",
            trainable=True           
        )
    def call(self,inputs):
        res=self.centers-inputs
        pre=tf.transpose(tf.exp(-abs(self.lambd)*tf.norm(res,axis=-1)**2))
        return tf.matmul(pre,self.weight)

class RadialDense2D(tf.keras.layers.Layer):
    def __init__(self,units):
        super(RadialDense2D, self).__init__()
        self.units=units

    def build(self,input_shape):
        print(input_shape)
        self.centers=self.add_weight(
            name='centers',
            shape=[self.units,1,int(input_shape[-2]),int(input_shape[-1])],
            initializer="random_normal",
            trainable=True
        )
        self.weight=self.add_weight(
            name='weight',
            shape=2*[self.units],
            initializer="random_normal",
            trainable=True
        )
        self.lambd=self.add_weight(
             name='lambda',
            shape=[1],
            initializer="random_normal",
            trainable=True           
        )
    def call(self,inputs):
        res=self.centers-inputs
        pre=tf.transpose(tf.exp(-abs(self.lambd)*tf.norm(res,axis=[-2,-1])**2))
        return tf.matmul(pre,self.weight)

class RadialConv2D(tf.keras.layers.Layer):

      def __init__(self, input_shape, filter_size, n_channels=1, stride=1, padding='valid'):
        super(RadialConv2D, self).__init__()
        self.stride = stride
        self.filter_size = filter_size
        self.input_size = (input_shape[0], input_shape[1])
        self.input_depth = input_shape[2]
        self.center_size = ( np.array(self.input_size) + np.array([1,1]) - np.array(self.filter_size)) / self.stride  # will change if padding is SAME, fix later
        self.n_channels = n_channels

      def build(self,input_shape): 
        self.centers=self.add_weight(
            name='centers',
            shape=[int(self.center_size[-2]), int(self.center_size[-1]), self.n_channels, 1,self.input_depth, int(self.filter_size[-2]), int(self.filter_size[-1])],
            initializer="random_normal",
            trainable=True
        )
        self.weight=self.add_weight(
            name='weight',
            shape=[int(self.center_size[-2]), int(self.center_size[-1]), self.n_channels],
            initializer="random_normal",
            trainable=True
        )
        self.lambd=self.add_weight(
             name='lambda',
            shape=[int(self.center_size[-2]), int(self.center_size[-1]), self.n_channels],
            initializer="random_normal",
            trainable=True         
        )

      def conv_op(self, inputs): 
        res2 = []
        
        for m in range(self.n_channels):
          res3 = tf.zeros_like( inputs [:,:int(self.center_size[-2]),:int(self.center_size[-1]),0])
          res2.append(tf.expand_dims(res3,axis=-1))

        res = tf.concat(res2, axis=-1)
        eyei=tf.ones(self.filter_size[-2])
        eyej=tf.ones(self.filter_size[-1])
        
        inputs = tf.transpose(inputs, (3,0,1,2))

        #for n in range( self.n_channels):

        for i in range( 0, int(self.center_size[-2]), int(self.stride) ):
          ri_matrix = tf.linalg.diag(eyei, k=i, num_rows = self.filter_size[-2], num_cols = self.input_size[-2] )

          for j in range( 0, int(self.center_size[-1]), int(self.stride) ):
            rj_matrix = tf.linalg.diag(eyej, k=j, num_rows =  self.filter_size[-1], num_cols = self.input_size[-1] )

            projection = tf.matmul( ri_matrix,  inputs)
            projection = tf.matmul(  projection, rj_matrix, transpose_b=True)
            projection = tf.transpose(projection, perm=(1,0,2,3) )

            pre =  projection - self.centers[i,j]

            exp = tf.sqrt(tf.reduce_sum(tf.square(pre),axis=[-3,-2,-1] ))
            exp = tf.transpose(exp)

            res_ij = self.weight[i,j] * tf.exp( self.lambd[i,j] * exp)

            eij_array = np.zeros( [int(self.center_size[-2]),int(self.center_size[-1]),])
            eij_array[i,j] = 1.0
            eij = tf.convert_to_tensor(eij_array, dtype=tf.float32)

            mult =  tf.tensordot(   res_ij ,eij, axes=0)
            mult = tf.transpose(mult, perm=(0,2,3,1))

            res = res + mult
        return res

      def call(self,inputs):
        return self.conv_op(inputs)